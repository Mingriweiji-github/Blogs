## 操作系统

## [Linux进程状态](https://www.cnblogs.com/littlecharacter/p/12154588.html)



理解操作系统是如何工作的

- 它如何决定接下来哪个程序使用 CPU
- 如何在虚拟内存系统中处理内存使用过载
- 虚拟机 监控器如何工作
- 如何管理磁盘上的数据，



[《Operating Systems: three easy pieces》](https://pages.cs.wisc.edu/~remzi/OSTEP/)

[中文版本](https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese)

今天介绍一本书，书名叫做：《Operating Systems: three easy pieces》。如果日常工作中和底层打交道的话会遇到很多操作系统相关的问题，比如：

- 为何系统会出现 load 值高 cpu 利用率却不高的情况？

- 为何会有那么多僵尸进程？

- 某些场景下如何快速创建进程的 snapshot ？

- 如何高效利用 CPU Cache Line（利用 Cache Friendly 的数据结构）？

- 如何避免 False Sharing ?

- 并发情况下如何避免死锁？

- zero-copy 为何高效？

- 单纯的 context switch 都是 micro second 级的，为何频繁的线程调度会导致性能低下？

- 各种锁（互斥锁、自旋锁、读写锁）的适用场景等。

  

UCLA CS系本科必修的操作系统就是这本教材

cs537 operating system





## 用户空间和内核空间的区别


> 用户空间就是进程的内存空间，内核空间就是操作系统的内存空间。
>
> 内核空间有很高权限，所以系统级命令，比如write fsync，需要进程从用户空间陷入内核空间，然后才能操作


![image-20210520115821592](https://raw.githubusercontent.com/Mingriweiji-github/ImageBed/master/img/20210520115833.png)